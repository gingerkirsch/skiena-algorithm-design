Problem: Give an efficient algorithm to determine whether two sets (of size m and n, respectively) are disjoint. Analyze the worst-case complexity in terms of m and n, considering the case where m is substantially smaller than n.
Solution: At least three algorithms come to mind, all of which are variants of sorting and searching:
• First sort the big set – The big set can be sorted in O(n log n) time. We can now do a binary search with each of the m elements in the second, looking to see if it exists in the big set. The total time will be O((n + m) log n).
• Firstsortthesmallset–ThesmallsetcanbesortedinO(mlogm)time.We can now do a binary search with each of the n elements in the big set, looking to see if it exists in the small one. The total time will be O((n + m) log m).
• Sort both sets – Observe that once the two sets are sorted, we no longer have to do binary search to detect a common element. We can compare the smallest elements of the two sorted sets, and discard the smaller one if they are not identical. By repeating this idea recursively on the now smaller sets, we can test for duplication in linear time after sorting. The total cost is O(nlogn+mlogm+n+m).


Problem: Given an array-based heap on n elements and a real number x, efficiently determine whether the kth smallest element in the heap is greater than or equal to x. Your algorithm should be O(k) in the worst-case, independent of the size of the heap. Hint: you do not have to find the kth smallest element; you need only determine its relationship to x.
Solution: There are at least two different ideas that lead to correct but inefficient algorithms for this problem:
1. Call extract-min k times, and test whether all of these are less than x. This explicitly sorts the first k elements and so gives us more information than the desired answer, but it takes O(k log n) time to do so.
2. The kth smallest element cannot be deeper than the kth level of the heap, since the path from it to the root must go through elements of decreasing value. Thus we can look at all the elements on the first k levels of the heap, and count how many of them are less than x, stopping when we either find k of them or run out of elements. This is correct, but takes O(min(n,2k)) time, since the top k elements have 2k elements.
